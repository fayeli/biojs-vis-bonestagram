<!doctype html>
<html lang="en">
	<head>
		<title>Bonestagram</title>
		<meta charset="utf-8">
		<style>
			@import url(https://fonts.googleapis.com/css?family=Lato:300italic,700italic,300,700);

			body {
				font-family: 'Lato';
				background-color: #f0f0f0;
				margin: 0px auto;
				max-width: 1150px;
			}
			
			
			#overlay, #webgl, #handoverlay {
				position: absolute;
				top: 0px;
				left: 0px;
				-o-transform : scaleX(-1);
				-webkit-transform : scaleX(-1);
				transform : scaleX(-1);
				-ms-filter : fliph; /*IE*/
				filter : fliph; /*IE*/
			}

			#videoel {
				-o-transform : scaleX(-1);
				-webkit-transform : scaleX(-1);
				transform : scaleX(-1);
				-ms-filter : fliph; /*IE*/
				filter : fliph; /*IE*/
			}

			#container {
				position : relative;
				width : 370px;
				/*margin : 0px auto;*/
			}
			
			#content {
				margin-top : 70px;
				margin-left : 100px;
				margin-right : 100px;
				max-width: 950px;
			}
			 
			#sketch {
				display: none;
			}
			
			#filter {
				display: none;
			}

			h2 {
				font-weight : 400;
			}

			.masks {
				display: none;
			}

			.nogum {
						display : none;
			}
			
			.btn {
						font-family: 'Lato';
						font-size: 16px;
			}

			.hide {
				display : none;
			}

			.nohide {
				display : block;
			}

			}
		</style>
		<script src="./ext_js/dat.gui.min.js"></script>
		<script src="./ext_js/utils.js"></script>
		<script src="./ext_js/jsfeat-min.js"></script>
		<script src="./ext_js/frontalface.js"></script>
		<script src="./ext_js/jsfeat_detect.js"></script>
		<script src="./ext_js/numeric-1.2.6.min.js"></script>
		<script src="./ext_js/mosse.js"></script>
		<script src="./ext_js/left_eye_filter.js"></script>
		<script src="./ext_js/right_eye_filter.js"></script>
		<script src="./ext_js/nose_filter.js"></script>
		<script src="./models/model_pca_20_svm.js"></script>
		<script src="./js/clm.js"></script>
		<script src="./js/svmfilter_webgl.js"></script>
		<script src="./js/svmfilter_fft.js"></script>
		<script src="./js/mossefilter.js"></script>
		<script src="./ext_js/Stats.js"></script>
		<script src="./js/face_deformer.js"></script>
		<script>
			var vid;
			var overlay;
			var overlayCC;
			var handoverlay;
			var handoverlayCC;
			var handhue;
			var ctrack;
			var offsetX;
			var offsetY;
			var mouseX;
			var mouseY;
			var curr_xy, prev_xy, curr_img_pyr, prev_img_pyr, point_count, point_status;

			var main = function() {
				vid = document.getElementById('videoel');
				overlay = document.getElementById('overlay');
				overlayCC = overlay.getContext('2d');
				handoverlay = document.getElementById('handoverlay');
				handoverlayCC = handoverlay.getContext('2d');
				offsetX = document.getElementById('container').offsetLeft;
				offsetY = document.getElementById('container').offsetTop;
				
				ctrack = new clm.tracker();
				ctrack.init(pModel);

				opticalFlowInit();
				
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				document.getElementById('container').appendChild( stats.domElement );
				
				// draw a bounding box for hand initial position
				// drawHandBBox();

				// clicking adds new tracking point
				handoverlay.addEventListener('click', function(e){
					mouseX = 400 - (e.pageX - offsetX);
					mouseY = e.pageY - offsetY;
					// bit wise shift, same as mutiply by 2
					curr_xy[point_count<<1] = mouseX;
					curr_xy[(point_count<<1)+1] = mouseY;
					point_count++;
					console.log(point_count);

				})

				function enablestart() {
					var startbutton = document.getElementById('startbutton');
					startbutton.value = "start";
					startbutton.disabled = null;
				}
				
				var insertAltVideo = function(video) {
					
					if (supports_video()) {
						if (supports_ogg_theora_video()) {
							video.src = "./media/cap13_edit2.ogv";
						} else if (supports_h264_baseline_video()) {
							video.src = "./media/cap13_edit2.mp4";
						} else {
							return false;
						}
						//video.play();
						return true;
					} else return false;
				}
				
				// check whether browser supports webGL
				var webGLContext;
				var webGLTestCanvas = document.createElement('canvas');
				if (window.WebGLRenderingContext) {
					webGLContext = webGLTestCanvas.getContext('webgl') || webGLTestCanvas.getContext('experimental-webgl');
					if (!webGLContext || !webGLContext.getExtension('OES_texture_float')) {
						webGLContext = null;
					}
				}
				if (webGLContext == null) {
					alert("Your browser does not seem to support WebGL. Unfortunately this face mask example depends on WebGL, so you'll have to try it in another browser. :(");
				}
				
				navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
				window.URL = window.URL || window.webkitURL || window.msURL || window.mozURL;
				
				// check for camerasupport
				if (navigator.getUserMedia) {
					// set up stream
					
					// chrome 19 shim
					var videoSelector = {video : true};
					if (window.navigator.appVersion.match(/Chrome\/(.*?) /)) {
						var chromeVersion = parseInt(window.navigator.appVersion.match(/Chrome\/(\d+)\./)[1], 10);
						if (chromeVersion < 20) {
							videoSelector = "video";
						}
					};
					
					navigator.getUserMedia(videoSelector, function( stream ) {
						if (vid.mozCaptureStream) {
							vid.mozSrcObject = stream;
						} else {
							vid.src = (window.URL && window.URL.createObjectURL(stream)) || stream;
						}
						vid.play();
					}, function() {
						insertAltVideo(vid);
						//document.getElementById('gum').className = "hide";
						//document.getElementById('nogum').className = "nohide";
						alert("There was some problem trying to fetch video from your webcam, using a fallback video instead.");
					});
				} else {
					insertAltVideo(vid)
					//document.getElementById('gum').className = "hide";
					//document.getElementById('nogum').className = "nohide";
					alert("Your browser does not seem to support getUserMedia, using a fallback video instead.");
				}

				vid.addEventListener('canplay', enablestart, false);
				}



			function startVideo() {
					// start video
					vid.play();
					// start tracking
					//ctrack.start(vid);
					opticalFlowLoop();
					//findHandColour(vid);
					//drawColorThresholdLoop();
					// start drawing face grid
					//drawGridLoop();
				}

			function opticalFlowLoop(){
				handoverlayCC.drawImage(vid, 0, 0,vid.width, vid.height);
				var imageData = handoverlayCC.getImageData(0,0,vid.width,vid.height);

				// swap flow data
				var _pt_xy = prev_xy;
				prev_xy = curr_xy;
				curr_xy = _pt_xy;
				var _pyr = prev_img_pyr;
				prev_img_pyr = curr_img_pyr;
				curr_img_pyr = _pyr;

				// Gray scale the image
				jsfeat.imgproc.grayscale(imageData.data, vid.width, vid.height,curr_img_pyr.data[0]);
				// Build image pyramid (smaller res images)
				curr_img_pyr.build(curr_img_pyr.data[0], true);
				// optical flow parameters
				var win_size = 20;
				var max_iter = 30;
				var epsilon = 0.01;
				var min_eigen = 0.001;

				jsfeat.optical_flow_lk.track(prev_img_pyr, curr_img_pyr, prev_xy, curr_xy, point_count, win_size|0, max_iter|0, point_status, epsilon, min_eigen);
				console.log(prev_xy);
				console.log(point_status);

				// draw result
				for (var i = 0; i < point_count; i++){
					// if the point is found well by optical flow
					//if (point_status[i] == 1){
						// draw the point
						handoverlayCC.fillStyle = "#98ff98";
   				 		handoverlayCC.fillRect(curr_xy[i<<1],curr_xy[(i<<1)+1],3,3);
					//}
				}
				requestAnimFrame(opticalFlowLoop);

			}

			function opticalFlowInit(){
				curr_img_pyr = new jsfeat.pyramid_t(3);
				prev_img_pyr = new jsfeat.pyramid_t(3);
				curr_img_pyr.allocate(vid.width,vid.height, jsfeat.U8_t|jsfeat.C1_t);
				prev_img_pyr.allocate(vid.width,vid.height, jsfeat.U8_t|jsfeat.C1_t);
				prev_xy = new Float32Array(100*2);
				curr_xy = new Float32Array(100*2);
				point_count = 0;
				point_status = new Uint8Array(100);

			}

			function findHandColour(video){
				var canvas = document.createElement('canvas');
				canvas.width = video.width;
				canvas.height = video.height;
				var ctx = canvas.getContext('2d');
				ctx.drawImage(video, 0, 0, video.width, video.height);
				var box_w = 150;
				var box_h = 175;
				// extract the image data of the hand bounding box
				var imageData = ctx.getImageData(200, 70, box_w, box_h);
				var r;
				var g;
				var b;
				var h;
				var s;
				var v;
				// Cast to normal non clamped array
				var rgb_array = Array.prototype.slice.call(imageData.data);
				//console.log(rgb_array);
				var hsv_array = [];
				for ( var i = 0; i < rgb_array.length; i +=4)
				{
					r = rgb_array[i];
					g = rgb_array[i+1];
					b = rgb_array[i+2];
					[h, s, v] = rgb2hsv(r,g,b);
					hsv_array[i] = h;
					hsv_array[i+1] = s*100;
					hsv_array[i+2] = v*100;
					hsv_array[i+3] = 255;
				}
				//console.log(hsv_array);

				// get the colour of one of the middle pixel (hand)
				var x = Math.round(box_w / 2);
				var y = Math.round((box_h * 2) / 3); //  two third down of the bounding box
				[r, g, b, h, s, v] = getPixel(x,y,box_w,rgb_array,hsv_array);
				console.log([r,g,b,h,s,v]);
				handhue = h;
				
				// filter pixels by similar hue to that of the hand
				for ( var i = 0; i < hsv_array.length; i +=4){
					if (hsv_array[i] > handhue + 15 || hsv_array[i] < handhue - 15 ){
						// set filtered out pixels to black
						imageData.data[i] = 0;
						imageData.data[i+1] = 0;
						imageData.data[i+2] = 0;	
					} 
				}


				// draw filtered image
				handoverlayCC.putImageData(imageData, 0, 0);
				//ctx.clearRect(0, 0, 400, 300);
				//ctx.putImageData(image_data, 0, 0);
				//var dataURL = canvas.toDataURL('image/png');
				//window.open(dataURL);
			}



			function getPixel(x,y,w,rgb_array,hsv_array){
				//console.log(x);
				//console.log(y);
				var i = ((y * w) + x) * 4;
				//console.log(i);
				var r = rgb_array[i];
				var g = rgb_array[i+1];
				var b = rgb_array[i+2];
				var h = hsv_array[i];
				var s = hsv_array[i+1];
				var v = hsv_array[i+2];
				return [r,g,b,h,s,v];
			}

			function rgb2hsv (r,g,b) {
 				var computedH = 0;
 				var computedS = 0;
 				var computedV = 0;

 				//remove spaces from input RGB values, convert to int
 				var r = parseInt( (''+r).replace(/\s/g,''),10 ); 
 				var g = parseInt( (''+g).replace(/\s/g,''),10 ); 
 				var b = parseInt( (''+b).replace(/\s/g,''),10 ); 

 				if ( r==null || g==null || b==null ||
     				isNaN(r) || isNaN(g)|| isNaN(b) ) {
   					alert ('Please enter numeric RGB values!');
   					return;
 				}
 				if (r<0 || g<0 || b<0 || r>255 || g>255 || b>255) {
   					alert ('RGB values must be in the range 0 to 255.');
   					return;
 				}
 				r=r/255; g=g/255; b=b/255;
 				var minRGB = Math.min(r,Math.min(g,b));
 				var maxRGB = Math.max(r,Math.max(g,b));

 				// Black-gray-white
 				if (minRGB==maxRGB) {
  					computedV = minRGB;
  					return [0,0,computedV];
 				}

 				// Colors other than black-gray-white:
 				var d = (r==minRGB) ? g-b : ((b==minRGB) ? r-g : b-r);
 				var h = (r==minRGB) ? 3 : ((b==minRGB) ? 1 : 5);
 				computedH = 60*(h - d/(maxRGB - minRGB));
 				computedS = (maxRGB - minRGB)/maxRGB;
 				computedV = maxRGB;
 				return [computedH,computedS,computedV];
			}

			function drawHandBBox() {
				handoverlayCC.clearRect(0, 0, 400, 300);
				handoverlayCC.setLineDash([7, 7]);
				handoverlayCC.strokeStyle="white";
				handoverlayCC.rect(200, 70, 150, 175);
				handoverlayCC.stroke();
			}

			function drawColorThresholdLoop() {
				var canvas = document.createElement('canvas');
				canvas.width = vid.width;
				canvas.height = vid.height;
				var ctx = canvas.getContext('2d');
				ctx.drawImage(vid, 0, 0, vid.width, vid.height);
				var imageData = ctx.getImageData(0, 0, vid.width, vid.height);
				var r;
				var g;
				var b;
				var h;
				var s;
				var v;
				// Cast to normal non clamped array
				var rgb_array = Array.prototype.slice.call(imageData.data);
				//console.log(rgb_array);
				var hsv_array = [];
				for ( var i = 0; i < rgb_array.length; i +=4)
				{
					r = rgb_array[i];
					g = rgb_array[i+1];
					b = rgb_array[i+2];
					[h, s, v] = rgb2hsv(r,g,b);
					hsv_array[i] = h;
					hsv_array[i+1] = s*100;
					hsv_array[i+2] = v*100;
					hsv_array[i+3] = 255;
				}

				// filter pixels by similar hue to that of the hand
				for ( var i = 0; i < hsv_array.length; i +=4){
					if (hsv_array[i] > handhue + 15 || hsv_array[i] < handhue - 15 ){
						// set filtered out pixels to black
						imageData.data[i] = 0;
						imageData.data[i+1] = 0;
						imageData.data[i+2] = 0;	
					} 
				}


				// draw filtered image
				handoverlayCC.putImageData(imageData, 0, 0);
				animationRequest = requestAnimFrame(drawColorThresholdLoop);	
			}				



			window.onload = main;			
				
					
			</script>
	</head>
	<body>
		<div id="content">
			<h2>Optical Flow</h2>
			<div id="container">
				<video id="videoel" width="400" height="300" preload="auto">
				</video>
				<canvas id="overlay" width="400" height="300"></canvas>
				<canvas id="webgl" width="400" height="300"></canvas>
				<canvas id="handoverlay" width="400" height="300"></canvas>
			</div>
			<br/>
			<input class="btn" type="button" value="wait, loading video" disabled="disabled" onclick="startVideo()" id="startbutton"></input>
		</div>
	</body>
</html>
